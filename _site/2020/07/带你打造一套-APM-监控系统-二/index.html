<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>带你打造一套 APM 监控系统（二）</title>
  <meta name="description" content="三、 CPU 使用率监控">
  <meta name="author" content="Gavin Guo">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="带你打造一套 APM 监控系统（二）">
  <meta name="twitter:description" content="三、 CPU 使用率监控">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="带你打造一套 APM 监控系统（二）">
  <meta property="og:description" content="三、 CPU 使用率监控">
  
  <link rel="icon" type="image/ico" href="/assets/images/favicon.ico" />
  <link href="/assets/images/favicon.ico" rel="shortcut icon" type="image/ico">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2020/07/%E5%B8%A6%E4%BD%A0%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97-APM-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E4%BA%8C/">
  <link rel="alternate" type="application/rss+xml" title="GSNICE" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</head>

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>

  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 GSNICE 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="GSNICE logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for GSNICE" class="blog-button">GSNICE</a></h1>

        
        <span class="panel-cover__subtitle panel-subtitle">上善若水，人淡如菊</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是郭承斌 (Gavin.Guo)，一名 iOS 开发者。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description">欢迎访问我的技术空间</p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="//blog.csdn.net/u012439446" target="_blank" title="我的 CSDN 博客">CSDN</a></li>
                
                  <li class="navigation__item"><a href="/resume" target="_blank" title="简历">简历</a></li>
                
                  <li class="navigation__item"><a href="/about" target="_blank" title="关于">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/dgnice" title="@dgnice 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/GSNICE" title="@GSNICE 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:sdjngcb@outlook.com" title="邮箱：sdjngcb@outlook.com">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-07-14 12:59:07 +0800" itemprop="datePublished" class="post-meta__date date">2020-07-14</time> &#8226; <span class="post-meta__tags tags">iOS</span>
    </div>
    <h1 class="post-title">带你打造一套 APM 监控系统（二）</h1>
  </header>

  <section class="post">
    <h2 id="三-cpu-使用率监控">三、 CPU 使用率监控</h2>

<h3 id="1-cpu-架构">1. CPU 架构</h3>

<p>CPU（Central Processing Unit）中央处理器，市场上主流的架构有 ARM（arm64）、Intel（x86）、AMD 等。其中 Intel 使用 CISC（Complex Instruction Set Computer），ARM 使用 RISC（Reduced Instruction Set Computer）。区别在于<strong>不同的 CPU 设计理念和方法</strong>。</p>

<p>早期 CPU 全部是 CISC 架构，设计目的是<strong>用最少的机器语言指令来完成所需的计算任务</strong>。比如对于乘法运算，在 CISC 架构的 CPU 上。一条指令 <code class="highlighter-rouge">MUL ADDRA, ADDRB</code> 就可以将内存 ADDRA 和内存 ADDRB 中的数香乘，并将结果存储在 ADDRA 中。做的事情就是：将 ADDRA、ADDRB 中的数据读入到寄存器，相乘的结果写入到内存的操作依赖于 CPU 设计，所以 <strong>CISC 架构会增加 CPU 的复杂性和对 CPU 工艺的要求。</strong></p>

<p>RISC 架构要求软件来指定各个操作步骤。比如上面的乘法，指令实现为 <code class="highlighter-rouge">MOVE A, ADDRA; MOVE B, ADDRB; MUL A, B; STR ADDRA, A;</code>。这种架构可以降低 CPU 的复杂性以及允许在同样的工艺水平下生产出功能更加强大的 CPU，但是对于编译器的设计要求更高。</p>

<p>目前市场是大部分的 iPhone 都是基于 arm64 架构的。且 arm 架构能耗低。</p>

<h3 id="2-获取线程信息">2. 获取线程信息</h3>

<p><strong>讲完了区别来讲下如何做 CPU 使用率的监控：</strong></p>

<ul>
  <li>开启定时器，按照设定的周期不断执行下面的逻辑</li>
  <li>获取当前任务 task。从当前 task 中获取所有的线程信息（线程个数、线程数组）</li>
  <li>遍历所有的线程信息，判断是否有线程的 CPU 使用率超过设置的阈值</li>
  <li>假如有线程使用率超过阈值，则 dump 堆栈</li>
  <li>组装数据，上报数据</li>
</ul>

<p><strong>线程信息结构体</strong></p>

<pre><code class="language-objectivec">struct thread_basic_info {
	time_value_t    user_time;      /* user run time（用户运行时长） */
	time_value_t    system_time;    /* system run time（系统运行时长） */ 
	integer_t       cpu_usage;      /* scaled cpu usage percentage（CPU使用率，上限1000） */
	policy_t        policy;         /* scheduling policy in effect（有效调度策略） */
	integer_t       run_state;      /* run state (运行状态，见下) */
	integer_t       flags;          /* various flags (各种各样的标记) */
	integer_t       suspend_count;  /* suspend count for thread（线程挂起次数） */
	integer_t       sleep_time;     /* number of seconds that thread
	                                 *  has been sleeping（休眠时间） */
};
</code></pre>

<p><strong>代码在讲堆栈还原的时候讲过，忘记的看一下上面的分析：</strong></p>

<pre><code class="language-objectivec">thread_act_array_t threads;
mach_msg_type_number_t threadCount = 0;
const task_t thisTask = mach_task_self();
kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);
if (kr != KERN_SUCCESS) {
    return ;
}
for (int i = 0; i &lt; threadCount; i++) {
    thread_info_data_t threadInfo;
    thread_basic_info_t threadBaseInfo;
    mach_msg_type_number_t threadInfoCount;
    
    kern_return_t kr = thread_info((thread_inspect_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount);
    
    if (kr == KERN_SUCCESS) {
        
        threadBaseInfo = (thread_basic_info_t)threadInfo;
        // todo：条件判断，看不明白
        if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) {
            integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / 10;
            if (cpuUsage &gt; CPUMONITORRATE) {
                
                NSMutableDictionary *CPUMetaDictionary = [NSMutableDictionary dictionary];
                NSData *CPUPayloadData = [NSData data];
                
                NSString *backtraceOfAllThread = [BacktraceLogger backtraceOfAllThread];
                // 1. 组装卡顿的 Meta 信息
                CPUMetaDictionary[@"MONITOR_TYPE"] = CMMonitorCPUType;
            
                // 2. 组装卡顿的 Payload 信息（一个JSON对象，对象的 Key 为约定好的 STACK_TRACE， value 为 base64 后的堆栈信息）
                NSData *CPUData = [SAFE_STRING(backtraceOfAllThread) dataUsingEncoding:NSUTF8StringEncoding];
                NSString *CPUDataBase64String = [CPUData base64EncodedStringWithOptions:0];
                NSDictionary *CPUPayloadDictionary = @{@"STACK_TRACE": SAFE_STRING(CPUDataBase64String)};
                
                NSError *error;
                // NSJSONWritingOptions 参数一定要传0，因为服务端需要根据 \n 处理逻辑，传递 0 则生成的 json 串不带 \n
                NSData *parsedData = [NSJSONSerialization dataWithJSONObject:CPUPayloadDictionary options:0 error:&amp;error];
                if (error) {
                    CMMLog(@"%@", error);
                    return;
                }
                CPUPayloadData = [parsedData copy];
                
                // 3. 数据上报会在 [打造功能强大、灵活可配置的数据上报组件](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) 讲
                [[PrismClient sharedInstance] sendWithType:CMMonitorCPUType meta:CPUMetaDictionary payload:CPUPayloadData]; 
            }
        }
    }
}
</code></pre>

<h2 id="四-oom-问题">四、 OOM 问题</h2>

<h3 id="1-基础知识准备">1. 基础知识准备</h3>

<p>硬盘：也叫做磁盘，用于存储数据。你存储的歌曲、图片、视频都是在硬盘里。</p>

<p>内存：由于硬盘读取速度较慢，如果 CPU 运行程序期间，所有的数据都直接从硬盘中读取，则非常影响效率。所以 CPU 会将程序运行所需要的数据从硬盘中读取到内存中。然后 CPU 与内存中的数据进行计算、交换。内存是易失性存储器（断电后，数据消失）。内存条区是计算机内部（在主板上）的一些存储器，用来保存 CPU 运算的中间数据和结果。内存是程序与 CPU 之间的桥梁。从硬盘读取出数据或者运行程序提供给 CPU。</p>

<p><strong>虚拟内存</strong> 是计算机系统内存管理的一种技术。它使得程序认为它拥有连续的可用内存，而实际上，它通常被分割成多个物理内存碎片，可能部分暂时存储在外部磁盘（硬盘）存储器上（当需要使用时则用硬盘中数据交换到内存中）。Windows 系统中称为 “虚拟内存”，Linux/Unix 系统中称为 ”交换空间“。</p>

<p>iOS 不支持交换空间？不只是 iOS 不支持交换空间，大多数手机系统都不支持。因为移动设备的大量存储器是<strong>闪存</strong>，它的读写速度远远小电脑所使用的硬盘，也就是说手机即使使用了<strong>交换空间</strong>技术，也因为闪存慢的问题，不能提升性能，所以索性就没有交换空间技术。</p>

<h3 id="2-ios-内存知识">2. iOS 内存知识</h3>

<p>内存（RAM）与 CPU 一样都是系统中最稀少的资源，也很容易发生竞争，应用内存与性能直接相关。iOS 没有交换空间作为备选资源，所以内存资源尤为重要。</p>

<p>什么是 OOM？是 out-of-memory 的缩写，字面意思是超过了内存限制。分为 FOOM（foreground OOM）和 BOOM（background OOM）。它是由 iOS 的 <code class="highlighter-rouge">Jetsam</code> 机制造成的一种非主流 Crash，它不能通过 Signal 这种监控方案所捕获。</p>

<p>什么是 Jetsam 机制？Jetsam 机制可以理解为系统为了控制内存资源过度使用而采用的一种管理机制。Jetsam 机制是运行在一个独立的进程中，每个进程都有一个内存阈值，一旦超过这个内存阈值，Jetsam 会立即杀掉这个进程。</p>

<p>为什么设计 Jetsam 机制？因为设备的内存是有限的，所以内存资源非常重要。系统进程以及其他使用的 App 都会抢占这个资源。由于 iOS 不支持交换空间，一旦触发低内存事件，Jetsam 就会尽可能多的释放 App 所在内存，这样 iOS 系统上出现内存不足时，App 就会被系统杀掉，变现为 crash。</p>

<p>2种情况触发 OOM：系统由于整体内存使用过高，会基于优先级策略杀死优先级较低的 App；当前 App 达到了 “<strong>highg water mark</strong>” ，系统也会强杀当前 App（超过系统对当前单个 App 的内存限制值）。</p>

<p>读了源码（xnu/bsd/kern/kern_memorystatus.c）会发现内存被杀也有2种机制，如下</p>

<p><strong>highwater 处理 -&gt; 我们的 App 占用内存不能超过单个限制：</strong></p>

<ol>
  <li>从优先级列表里循环寻找线程</li>
  <li>判断是否满足 p_memstat_memlimit 的限制条件</li>
  <li>DiagonoseActive、FREEZE 过滤</li>
  <li>杀进程，成功则 exit，否则循环</li>
</ol>

<p><strong>memorystatus_act_aggressive 处理 -&gt; 内存占用高，按照优先级杀死：</strong></p>

<ol>
  <li>根据 policy 家在 jld_bucket_count，用来判断是否被杀</li>
  <li>从 JETSAM_PRIORITY_ELEVATED_INACTIVE 开始杀</li>
  <li>Old_bucket_count 和 memorystatus_jld_eval_period_msecs 判断是否开杀</li>
  <li>根据优先级从低到高开始杀，直到 memorystatus_avail_pages_below_pressure</li>
</ol>

<p><strong>内存过大的几种情况</strong></p>

<ul>
  <li>App 内存消耗较低，同时其他 App 内存管理也很棒，那么即使切换到其他 App，我们自己的 App 依旧是“活着”的，保留了用户状态。体验好</li>
  <li>App 内存消耗较低，但其他 App 内存消耗太大（可能是内存管理糟糕，也可能是本身就耗费资源，比如游戏），那么除了在前台的线程，其他 App 都会被系统杀死，回收内存资源，用来给活跃的进程提供内存。</li>
  <li>App 内存消耗较大，切换到其他 App 后，即使其他 App 向系统申请的内存不大，系统也会因为内存资源紧张，优先把内存消耗大的 App 杀死。表现为用户将 App 退出到后台，过会儿再次打开会发现 App 重新加载启动。</li>
  <li>App 内存消耗非常大，在前台运行时就被系统杀死，造成闪退。</li>
</ul>

<p>App 内存不足时，系统会按照一定策略来腾出更多的空间供使用。比较常见的做法是将一部分优先级低的数据挪到磁盘上，该操作为称为 <strong>page out</strong>。之后再次访问这块数据的时候，系统会负责将它重新搬回到内存中，该操作被称为 <strong>page in</strong>。</p>

<p>Memory page** 是内存管理中的最小单位，是系统分配的，可能一个 page 持有多个对象，也可能一个大的对象跨越多个 page。通常它是 16KB 大小，且有3种类型的 page。</p>

<p><img src="https://img-blog.csdnimg.cn/20200714094103136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>

<ul>
  <li>
    <p>Clean Memory
  Clean memory 包括3类：可以 <code class="highlighter-rouge">page out</code> 的内存、内存映射文件、App 使用到的 framework（每个 framework 都有 _DATA_CONST 段，通常都是 clean 状态，但使用 runtime swizling，那么变为 dirty）。</p>

    <p>一开始分配的 page 都是干净的（堆里面的对象分配除外），我们 App 数据写入时候变为 dirty。从硬盘读进内存的文件，也是只读的、clean page。</p>
  </li>
</ul>

<p><img src="https://img-blog.csdnimg.cn/20200714094121564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>

<ul>
  <li>
    <p>Dirty Memory</p>

    <p>Dirty memory 包括4类：被 App 写入过数据的内存、所有堆区分配的对象、图像解码缓冲区、framework（framework 都有 _DATA 段和 _DATA_DIRTY 段，它们的内存都是 dirty）。</p>

    <p>在使用 framework 的过程中会产生 Dirty memory，使用单例或者全局初始化方法有助于帮助减少 Dirty memory（因为单例一旦创建就不销毁，一直在内存中，系统不认为是 Dirty memory）。</p>
  </li>
</ul>

<p><img src="https://img-blog.csdnimg.cn/20200714094145596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>

<ul>
  <li>
    <p>Compressed Memory</p>

    <p>由于闪存容量和读写限制，iOS 没有交换空间机制，而是在 iOS7 引入了 <strong>memory compressor</strong>。它是在内存紧张时候能够将最近一段时间未使用过的内存对象，内存压缩器会把对象压缩，释放出更多的 page。在需要时内存压缩器对其解压复用。在节省内存的同时提高了响应速度。</p>

    <p>比如 App 使用某 Framework，内部有个 NSDictionary 属性存储数据，使用了 3 pages 内存，在近期未被访问的时候 memory compressor 将其压缩为 1 page，再次使用的时候还原为 3 pages。</p>
  </li>
</ul>

<p>App 运行内存 = pageNumbers * pageSize。因为 Compressed Memory 属于 Dirty memory。所以 Memory footprint = dirtySize + CompressedSize</p>

<p>设备不同，内存占用上限不同，App 上限较高，extension 上限较低，超过上限 crash 到 <code class="highlighter-rouge">EXC_RESOURCE_EXCEPTION</code>。</p>

<p><img src="https://img-blog.csdnimg.cn/20200714094216738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>

<p>接下来谈一下如何获取内存上限，以及如何监控 App 因为占用内存过大而被强杀。</p>

<h3 id="3-获取内存信息">3. 获取内存信息</h3>

<h4 id="31-通过-jetsamevent-日志计算内存限制值">3.1 通过 JetsamEvent 日志计算内存限制值</h4>

<p>当 App 被 Jetsam 机制杀死时，手机会生成系统日志。查看路径：Settings-Privacy-Analytics &amp; Improvements- Analytics Data（设置-隐私- 分析与改进-分析数据），可以看到 <code class="highlighter-rouge">JetsamEvent-2020-03-14-161828.ips</code> 形式的日志，以 JetsamEvent 开头。这些 JetsamEvent 日志都是 iOS 系统内核强杀掉那些优先级不高（idle、frontmost、suspended）且占用内存超过系统内存限制的 App 留下的。</p>

<p>日志包含了 App 的内存信息。可以查看到 日志最顶部有 <code class="highlighter-rouge">pageSize</code> 字段，查找到 per-process-limit，该节点所在结构里的 <code class="highlighter-rouge">rpages</code> ，将 rpages * pageSize 即可得到 OOM 的阈值。</p>

<p>日志中 largestProcess 字段代表 App 名称；reason 字段代表内存原因；states 字段代表奔溃时 App 的状态（ idle、suspended、frontmost…）。</p>

<p>为了测试数据的准确性，我将测试2台设备（iPhone 6s plus/13.3.1，iPhone 11 Pro/13.3.1）的所有 App 彻底退出，只跑了一个为了测试内存临界值的 Demo App。 循环申请内存，ViewController 代码如下</p>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];
    NSMutableArray *array = [NSMutableArray array];
    for (NSInteger index = 0; index &lt; 10000000; index++) {
        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
        UIImage *image = [UIImage imageNamed:@"AppIcon"];
        imageView.image = image;
        [array addObject:imageView];
    }
}
</code></pre>

<p><strong>iPhone 6s plus/13.3.1 数据如下：</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="s2">"bug_type"</span>:<span class="s2">"298"</span>,<span class="s2">"timestamp"</span>:<span class="s2">"2020-03-19 17:23:45.94 +0800"</span>,<span class="s2">"os_version"</span>:<span class="s2">"iPhone OS 13.3.1 (17D50)"</span>,<span class="s2">"incident_id"</span>:<span class="s2">"DA8AF66D-24E8-458C-8734-981866942168"</span><span class="o">}</span>
<span class="o">{</span>
  <span class="s2">"crashReporterKey"</span> : <span class="s2">"fc9b659ce486df1ed1b8062d5c7c977a7eb8c851"</span>,
  <span class="s2">"kernel"</span> : <span class="s2">"Darwin Kernel Version 19.3.0: Thu Jan  9 21:10:44 PST 2020; root:xnu-6153.82.3~1</span><span class="se">\/</span><span class="s2">RELEASE_ARM64_S8000"</span>,
  <span class="s2">"product"</span> : <span class="s2">"iPhone8,2"</span>,
  <span class="s2">"incident"</span> : <span class="s2">"DA8AF66D-24E8-458C-8734-981866942168"</span>,
  <span class="s2">"date"</span> : <span class="s2">"2020-03-19 17:23:45.93 +0800"</span>,
  <span class="s2">"build"</span> : <span class="s2">"iPhone OS 13.3.1 (17D50)"</span>,
  <span class="s2">"timeDelta"</span> : 332,
  <span class="s2">"memoryStatus"</span> : <span class="o">{</span>
  <span class="s2">"compressorSize"</span> : 48499,
  <span class="s2">"compressions"</span> : 7458651,
  <span class="s2">"decompressions"</span> : 5190200,
  <span class="s2">"zoneMapCap"</span> : 744407040,
  <span class="s2">"largestZone"</span> : <span class="s2">"APFS_4K_OBJS"</span>,
  <span class="s2">"largestZoneSize"</span> : 41402368,
  <span class="s2">"pageSize"</span> : 16384,
  <span class="s2">"uncompressed"</span> : 104065,
  <span class="s2">"zoneMapSize"</span> : 141606912,
  <span class="s2">"memoryPages"</span> : <span class="o">{</span>
    <span class="s2">"active"</span> : 26214,
    <span class="s2">"throttled"</span> : 0,
    <span class="s2">"fileBacked"</span> : 14903,
    <span class="s2">"wired"</span> : 20019,
    <span class="s2">"anonymous"</span> : 37140,
    <span class="s2">"purgeable"</span> : 142,
    <span class="s2">"inactive"</span> : 23669,
    <span class="s2">"free"</span> : 2967,
    <span class="s2">"speculative"</span> : 2160
  <span class="o">}</span>
<span class="o">}</span>,
  <span class="s2">"largestProcess"</span> : <span class="s2">"Test"</span>,
  <span class="s2">"genCounter"</span> : 0,
  <span class="s2">"processes"</span> : <span class="o">[</span>
  <span class="o">{</span>
    <span class="s2">"uuid"</span> : <span class="s2">"39c5738b-b321-3865-a731-68064c4f7a6f"</span>,
    <span class="s2">"states"</span> : <span class="o">[</span>
      <span class="s2">"daemon"</span>,
      <span class="s2">"idle"</span>
    <span class="o">]</span>,
    <span class="s2">"lifetimeMax"</span> : 188,
    <span class="s2">"age"</span> : 948223699030,
    <span class="s2">"purgeable"</span> : 0,
    <span class="s2">"fds"</span> : 25,
    <span class="s2">"coalition"</span> : 422,
    <span class="s2">"rpages"</span> : 177,
    <span class="s2">"pid"</span> : 282,
    <span class="s2">"idleDelta"</span> : 824711280,
    <span class="s2">"name"</span> : <span class="s2">"com.apple.Safari.SafeBrowsing.Se"</span>,
    <span class="s2">"cpuTime"</span> : 10.275422000000001
  <span class="o">}</span>,
  // ...
  <span class="o">{</span>
    <span class="s2">"uuid"</span> : <span class="s2">"83dbf121-7c0c-3ab5-9b66-77ee926e1561"</span>,
    <span class="s2">"states"</span> : <span class="o">[</span>
      <span class="s2">"frontmost"</span>
    <span class="o">]</span>,
    <span class="s2">"killDelta"</span> : 2592,
    <span class="s2">"genCount"</span> : 0,
    <span class="s2">"age"</span> : 1531004794,
    <span class="s2">"purgeable"</span> : 0,
    <span class="s2">"fds"</span> : 50,
    <span class="s2">"coalition"</span> : 1047,
    <span class="s2">"rpages"</span> : 92806,
    <span class="s2">"reason"</span> : <span class="s2">"per-process-limit"</span>,
    <span class="s2">"pid"</span> : 2384,
    <span class="s2">"cpuTime"</span> : 59.464373999999999,
    <span class="s2">"name"</span> : <span class="s2">"Test"</span>,
    <span class="s2">"lifetimeMax"</span> : 92806
  <span class="o">}</span>,
  // ...
 <span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>iPhone 6s plus/13.3.1 手机 OOM 临界值为：(16384*92806)/(1024*1024)=1450.09375M</p>

<p><strong>iPhone 11 Pro/13.3.1 数据如下：</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span><span class="s2">"bug_type"</span>:<span class="s2">"298"</span>,<span class="s2">"timestamp"</span>:<span class="s2">"2020-03-19 17:30:28.39 +0800"</span>,<span class="s2">"os_version"</span>:<span class="s2">"iPhone OS 13.3.1 (17D50)"</span>,<span class="s2">"incident_id"</span>:<span class="s2">"7F111601-BC7A-4BD7-A468-CE3370053057"</span><span class="o">}</span>
<span class="o">{</span>
  <span class="s2">"crashReporterKey"</span> : <span class="s2">"bc2445adc164c399b330f812a48248e029e26276"</span>,
  <span class="s2">"kernel"</span> : <span class="s2">"Darwin Kernel Version 19.3.0: Thu Jan  9 21:11:10 PST 2020; root:xnu-6153.82.3~1</span><span class="se">\/</span><span class="s2">RELEASE_ARM64_T8030"</span>,
  <span class="s2">"product"</span> : <span class="s2">"iPhone12,3"</span>,
  <span class="s2">"incident"</span> : <span class="s2">"7F111601-BC7A-4BD7-A468-CE3370053057"</span>,
  <span class="s2">"date"</span> : <span class="s2">"2020-03-19 17:30:28.39 +0800"</span>,
  <span class="s2">"build"</span> : <span class="s2">"iPhone OS 13.3.1 (17D50)"</span>,
  <span class="s2">"timeDelta"</span> : 189,
  <span class="s2">"memoryStatus"</span> : <span class="o">{</span>
  <span class="s2">"compressorSize"</span> : 66443,
  <span class="s2">"compressions"</span> : 25498129,
  <span class="s2">"decompressions"</span> : 15532621,
  <span class="s2">"zoneMapCap"</span> : 1395015680,
  <span class="s2">"largestZone"</span> : <span class="s2">"APFS_4K_OBJS"</span>,
  <span class="s2">"largestZoneSize"</span> : 41222144,
  <span class="s2">"pageSize"</span> : 16384,
  <span class="s2">"uncompressed"</span> : 127027,
  <span class="s2">"zoneMapSize"</span> : 169639936,
  <span class="s2">"memoryPages"</span> : <span class="o">{</span>
    <span class="s2">"active"</span> : 58652,
    <span class="s2">"throttled"</span> : 0,
    <span class="s2">"fileBacked"</span> : 20291,
    <span class="s2">"wired"</span> : 45838,
    <span class="s2">"anonymous"</span> : 96445,
    <span class="s2">"purgeable"</span> : 4,
    <span class="s2">"inactive"</span> : 54368,
    <span class="s2">"free"</span> : 5461,
    <span class="s2">"speculative"</span> : 3716
  <span class="o">}</span>
<span class="o">}</span>,
  <span class="s2">"largestProcess"</span> : <span class="s2">"杭城小刘"</span>,
  <span class="s2">"genCounter"</span> : 0,
  <span class="s2">"processes"</span> : <span class="o">[</span>
  <span class="o">{</span>
    <span class="s2">"uuid"</span> : <span class="s2">"2dd5eb1e-fd31-36c2-99d9-bcbff44efbb7"</span>,
    <span class="s2">"states"</span> : <span class="o">[</span>
      <span class="s2">"daemon"</span>,
      <span class="s2">"idle"</span>
    <span class="o">]</span>,
    <span class="s2">"lifetimeMax"</span> : 171,
    <span class="s2">"age"</span> : 5151034269954,
    <span class="s2">"purgeable"</span> : 0,
    <span class="s2">"fds"</span> : 50,
    <span class="s2">"coalition"</span> : 66,
    <span class="s2">"rpages"</span> : 164,
    <span class="s2">"pid"</span> : 11276,
    <span class="s2">"idleDelta"</span> : 3801132318,
    <span class="s2">"name"</span> : <span class="s2">"wcd"</span>,
    <span class="s2">"cpuTime"</span> : 3.430787
  <span class="o">}</span>,
  // ...
  <span class="o">{</span>
    <span class="s2">"uuid"</span> : <span class="s2">"63158edc-915f-3a2b-975c-0e0ac4ed44c0"</span>,
    <span class="s2">"states"</span> : <span class="o">[</span>
      <span class="s2">"frontmost"</span>
    <span class="o">]</span>,
    <span class="s2">"killDelta"</span> : 4345,
    <span class="s2">"genCount"</span> : 0,
    <span class="s2">"age"</span> : 654480778,
    <span class="s2">"purgeable"</span> : 0,
    <span class="s2">"fds"</span> : 50,
    <span class="s2">"coalition"</span> : 1718,
    <span class="s2">"rpages"</span> : 134278,
    <span class="s2">"reason"</span> : <span class="s2">"per-process-limit"</span>,
    <span class="s2">"pid"</span> : 14206,
    <span class="s2">"cpuTime"</span> : 23.955463999999999,
    <span class="s2">"name"</span> : <span class="s2">"杭城小刘"</span>,
    <span class="s2">"lifetimeMax"</span> : 134278
  <span class="o">}</span>,
  // ...
 <span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>iPhone 11 Pro/13.3.1 手机 OOM 临界值为：(16384*134278)/(1024*1024)=2098.09375M</p>

<p><strong>iOS 系统如何发现 Jetsam ？</strong></p>

<p>MacOS/iOS 是一个 BSD 衍生而来的系统，其内核是 Mach，但是对于上层暴露的接口一般是基于 BSD 层对 Mach 的包装后的。Mach 是一个微内核的架构，真正的虚拟内存管理也是在其中进行的，BSD 对内存管理提供了上层接口。Jetsam 事件也是由 BSD 产生的。<code class="highlighter-rouge">bsd_init</code> 函数是入口，其中基本都是在初始化各个子系统，比如虚拟内存管理等。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. Initialize the kernel memory allocator, 初始化 BSD 内存 Zone，这个 Zone 是基于 Mach 内核的zone 构建</span>
<span class="n">kmeminit</span><span class="p">();</span>

<span class="c1">// 2. Initialise background freezing, iOS 上独有的特性，内存和进程的休眠的常驻监控线程</span>
<span class="cp">#if CONFIG_FREEZE
#ifndef CONFIG_MEMORYSTATUS
</span>    <span class="cp">#error "CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS"
#endif
</span>    <span class="cm">/* Initialise background freezing */</span>
    <span class="n">bsd_init_kprintf</span><span class="p">(</span><span class="s">"calling memorystatus_freeze_init</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">memorystatus_freeze_init</span><span class="p">();</span>
<span class="cp">#endif&gt;
</span>
<span class="c1">// 3. iOS 独有，JetSAM（即低内存事件的常驻监控线程）</span>
<span class="cp">#if CONFIG_MEMORYSTATUS
</span>    <span class="cm">/* Initialize kernel memory status notifications */</span>
    <span class="n">bsd_init_kprintf</span><span class="p">(</span><span class="s">"calling memorystatus_init</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">memorystatus_init</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORYSTATUS */</span><span class="cp">
</span></code></pre></div></div>

<p><strong>主要作用就是开启了2个优先级最高的线程，来监控整个系统的内存情况。</strong></p>

<p>CONFIG_FREEZE 开启时，内核对进程进行冷冻而不是杀死。冷冻功能是由内核中启动一个 <code class="highlighter-rouge">memorystatus_freeze_thread</code> 进行，这个进程在收到信号后调用 <code class="highlighter-rouge">memorystatus_freeze_top_process</code> 进行冷冻。</p>

<p>iOS 系统会开启优先级最高的线程 <code class="highlighter-rouge">vm_pressure_monitor</code> 来监控系统的内存压力情况，并通过一个堆栈来维护所有 App 进程。iOS 系统还会维护一个内存快照表，用于保存每个进程内存页的消耗情况。有关 Jetsam 也就是 memorystatus 相关的逻辑，可以在 XNU 项目中的 <strong>kern_memorystatus.h</strong> 和 **kern_memorystatus.c **源码中查看。</p>

<p>iOS 系统因内存占用过高会强杀 App 前，至少有 6秒钟可以用来做优先级判断，JetsamEvent 日志也是在这6秒内生成的。</p>

<p>上文提到了 iOS 系统没有交换空间，于是引入了 <strong>MemoryStatus 机制（也称为 Jetsam）</strong>。也就是说在 iOS 系统上释放尽可能多的内存供当前 App 使用。这个机制表现在优先级上，就是先强杀后台应用；如果内存还是不够多，就强杀掉当前应用。在 MacOS 中，MemoryStatus 只会强杀掉标记为空闲退出的进程。</p>

<p>MemoryStatus 机制会开启一个 memorystatus_jetsam_thread 的线程，它负责强杀 App 和记录日志，不会发送消息，所以内存压力检测线程无法获取到强杀 App 的消息。</p>

<p>当监控线程发现某 App 有内存压力时，就发出通知，此时有内存的 App 就去执行 <code class="highlighter-rouge">didReceiveMemoryWarning</code> 代理方法。在这个时机，我们还有机会做一些内存资源释放的逻辑，也许会避免 App 被系统杀死。</p>

<p><strong>源码角度查看问题</strong></p>

<p>iOS 系统内核有一个数组，专门维护线程的优先级。数组的每一项是一个包含进程链表的结构体。结构体如下：</p>

<pre><code class="language-objectivec">#define MEMSTAT_BUCKET_COUNT (JETSAM_PRIORITY_MAX + 1)

typedef struct memstat_bucket {
    TAILQ_HEAD(, proc) list;
    int count;
} memstat_bucket_t;

memstat_bucket_t memstat_bucket[MEMSTAT_BUCKET_COUNT];
</code></pre>

<p>在 kern_memorystatus.h 中可以看到进行优先级信息：</p>

<pre><code class="language-objectivec">#define JETSAM_PRIORITY_IDLE_HEAD                -2
/* The value -1 is an alias to JETSAM_PRIORITY_DEFAULT */
#define JETSAM_PRIORITY_IDLE                      0
#define JETSAM_PRIORITY_IDLE_DEFERRED		  1 /* Keeping this around till all xnu_quick_tests can be moved away from it.*/
#define JETSAM_PRIORITY_AGING_BAND1		  JETSAM_PRIORITY_IDLE_DEFERRED
#define JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC  2
#define JETSAM_PRIORITY_AGING_BAND2		  JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC
#define JETSAM_PRIORITY_BACKGROUND                3
#define JETSAM_PRIORITY_ELEVATED_INACTIVE	  JETSAM_PRIORITY_BACKGROUND
#define JETSAM_PRIORITY_MAIL                      4
#define JETSAM_PRIORITY_PHONE                     5
#define JETSAM_PRIORITY_UI_SUPPORT                8
#define JETSAM_PRIORITY_FOREGROUND_SUPPORT        9
#define JETSAM_PRIORITY_FOREGROUND               10
#define JETSAM_PRIORITY_AUDIO_AND_ACCESSORY      12
#define JETSAM_PRIORITY_CONDUCTOR                13
#define JETSAM_PRIORITY_HOME                     16
#define JETSAM_PRIORITY_EXECUTIVE                17
#define JETSAM_PRIORITY_IMPORTANT                18
#define JETSAM_PRIORITY_CRITICAL                 19

#define JETSAM_PRIORITY_MAX                      21
</code></pre>

<p>可以明显的看到，后台 App 优先级 JETSAM_PRIORITY_BACKGROUND 为3，前台 App 优先级 JETSAM_PRIORITY_FOREGROUND 为10。</p>

<p>优先级规则是：内核线程优先级 &gt; 操作系统优先级 &gt;  App 优先级。且前台 App 优先级高于后台运行的 App；当线程的优先级相同时， CPU 占用多的线程的优先级会被降低。</p>

<p><strong>在 kern_memorystatus.c 中可以看到 OOM 可能的原因：</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span> For logging clarity <span class="k">*</span>/
static const char <span class="k">*</span>memorystatus_kill_cause_name[] <span class="o">=</span> <span class="o">{</span>
	<span class="s2">""</span>								,		/<span class="k">*</span> kMemorystatusInvalid							<span class="k">*</span>/
	<span class="s2">"jettisoned"</span>					,		/<span class="k">*</span> kMemorystatusKilled							<span class="k">*</span>/
	<span class="s2">"highwater"</span>						,		/<span class="k">*</span> kMemorystatusKilledHiwat						<span class="k">*</span>/
	<span class="s2">"vnode-limit"</span>					,		/<span class="k">*</span> kMemorystatusKilledVnodes					<span class="k">*</span>/
	<span class="s2">"vm-pageshortage"</span>				,		/<span class="k">*</span> kMemorystatusKilledVMPageShortage			<span class="k">*</span>/
	<span class="s2">"proc-thrashing"</span>				,		/<span class="k">*</span> kMemorystatusKilledProcThrashing				<span class="k">*</span>/
	<span class="s2">"fc-thrashing"</span>					,		/<span class="k">*</span> kMemorystatusKilledFCThrashing				<span class="k">*</span>/
	<span class="s2">"per-process-limit"</span>				,		/<span class="k">*</span> kMemorystatusKilledPerProcessLimit			<span class="k">*</span>/
	<span class="s2">"disk-space-shortage"</span>			,		/<span class="k">*</span> kMemorystatusKilledDiskSpaceShortage			<span class="k">*</span>/
	<span class="s2">"idle-exit"</span>						,		/<span class="k">*</span> kMemorystatusKilledIdleExit					<span class="k">*</span>/
	<span class="s2">"zone-map-exhaustion"</span>			,		/<span class="k">*</span> kMemorystatusKilledZoneMapExhaustion			<span class="k">*</span>/
	<span class="s2">"vm-compressor-thrashing"</span>		,		/<span class="k">*</span> kMemorystatusKilledVMCompressorThrashing		<span class="k">*</span>/
	<span class="s2">"vm-compressor-space-shortage"</span>	,		/<span class="k">*</span> kMemorystatusKilledVMCompressorSpaceShortage	<span class="k">*</span>/
<span class="o">}</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>查看 memorystatus_init 这个函数中初始化 Jetsam 线程的关键代码：</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__private_extern__</span> <span class="kt">void</span>
<span class="nf">memorystatus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// ...</span>
  <span class="cm">/* Initialize the jetsam_threads state array */</span>
	<span class="n">jetsam_threads</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jetsam_thread_state</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_jetsam_threads</span><span class="p">);</span>
  
	<span class="cm">/* Initialize all the jetsam threads */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_jetsam_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">kernel_thread_start_priority</span><span class="p">(</span><span class="n">memorystatus_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">95</span> <span class="cm">/* MAXPRI_KERNEL */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jetsam_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="kr">thread</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jetsam_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">inited</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="n">jetsam_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">thread_deallocate</span><span class="p">(</span><span class="n">jetsam_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="kr">thread</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">"Could not create memorystatus_thread %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/<span class="k">*</span>
 <span class="k">*</span>	High-level priority assignments
 <span class="k">*</span>
 <span class="k">*************************************************************************</span>
 <span class="k">*</span> 127		Reserved <span class="o">(</span>real-time<span class="o">)</span>
 <span class="k">*</span>				A
 <span class="k">*</span>				+
 <span class="k">*</span>			<span class="o">(</span>32 levels<span class="o">)</span>
 <span class="k">*</span>				+
 <span class="k">*</span>				V
 <span class="k">*</span> 96		Reserved <span class="o">(</span>real-time<span class="o">)</span>
 <span class="k">*</span> 95		Kernel mode only
 <span class="k">*</span>				A
 <span class="k">*</span>				+
 <span class="k">*</span>			<span class="o">(</span>16 levels<span class="o">)</span>
 <span class="k">*</span>				+
 <span class="k">*</span>				V
 <span class="k">*</span> 80		Kernel mode only
 <span class="k">*</span> 79		System high priority
 <span class="k">*</span>				A
 <span class="k">*</span>				+
 <span class="k">*</span>			<span class="o">(</span>16 levels<span class="o">)</span>
 <span class="k">*</span>				+
 <span class="k">*</span>				V
 <span class="k">*</span> 64		System high priority
 <span class="k">*</span> 63		Elevated priorities
 <span class="k">*</span>				A
 <span class="k">*</span>				+
 <span class="k">*</span>			<span class="o">(</span>12 levels<span class="o">)</span>
 <span class="k">*</span>				+
 <span class="k">*</span>				V
 <span class="k">*</span> 52		Elevated priorities
 <span class="k">*</span> 51		Elevated priorities <span class="o">(</span>incl. BSD +nice<span class="o">)</span>
 <span class="k">*</span>				A
 <span class="k">*</span>				+
 <span class="k">*</span>			<span class="o">(</span>20 levels<span class="o">)</span>
 <span class="k">*</span>				+
 <span class="k">*</span>				V
 <span class="k">*</span> 32		Elevated priorities <span class="o">(</span>incl. BSD +nice<span class="o">)</span>
 <span class="k">*</span> 31		Default <span class="o">(</span>default base <span class="k">for </span>threads<span class="o">)</span>
 <span class="k">*</span> 30		Lowered priorities <span class="o">(</span>incl. BSD <span class="nt">-nice</span><span class="o">)</span>
 <span class="k">*</span>				A
 <span class="k">*</span>				+
 <span class="k">*</span>			<span class="o">(</span>20 levels<span class="o">)</span>
 <span class="k">*</span>				+
 <span class="k">*</span>				V
 <span class="k">*</span> 11		Lowered priorities <span class="o">(</span>incl. BSD <span class="nt">-nice</span><span class="o">)</span>
 <span class="k">*</span> 10		Lowered priorities <span class="o">(</span>aged pri<span class="s1">'s)
 *				A
 *				+
 *			(11 levels)
 *				+
 *				V
 * 0		Lowered priorities (aged pri'</span>s / idle<span class="o">)</span>
 <span class="k">*************************************************************************</span>
 <span class="k">*</span>/
</code></pre></div></div>

<p>可以看出：用户态的应用程序的线程不可能高于操作系统和内核。而且，用户态的应用程序间的线程优先级分配也有区别，比如处于前台的应用程序优先级高于处于后台的应用程序优先级。iOS 上应用程序优先级最高的是 SpringBoard；此外线程的优先级不是一成不变的。Mach 会根据线程的利用率和系统整体负载动态调整线程优先级。如果耗费 CPU 太多就降低线程优先级，如果线程过度挨饿，则会提升线程优先级。但是无论怎么变，程序都不能超过其所在线程的优先级区间范围。</p>

<p>可以看出，系统会根据内核启动参数和设备性能，开启 max_jetsam_threads 个（一般情况为1，特殊情况下可能为3）jetsam 线程，且这些线程的优先级为 95，也就是 MAXPRI_KERNEL（注意这里的 95 是线程的优先级，XNU 的线程优先级区间为：0～127。上文的宏定义是进程优先级，区间为：-2~19）。</p>

<p>紧接着，分析下 memorystatus_thread 函数，主要负责线程启动的初始化</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">memorystatus_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span> <span class="n">__unused</span><span class="p">,</span> <span class="n">wait_result_t</span> <span class="n">wr</span> <span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">memorystatus_action_needed</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">boolean_t</span> <span class="n">killed</span><span class="p">;</span>
		<span class="kt">int32_t</span> <span class="n">priority</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">cause</span><span class="p">;</span>
		<span class="kt">uint64_t</span> <span class="n">jetsam_reason_code</span> <span class="o">=</span> <span class="n">JETSAM_REASON_INVALID</span><span class="p">;</span>
		<span class="n">os_reason_t</span> <span class="n">jetsam_reason</span> <span class="o">=</span> <span class="n">OS_REASON_NULL</span><span class="p">;</span>

		<span class="n">cause</span> <span class="o">=</span> <span class="n">kill_under_pressure_cause</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cause</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">kMemorystatusKilledFCThrashing</span><span class="p">:</span>
				<span class="n">jetsam_reason_code</span> <span class="o">=</span> <span class="n">JETSAM_REASON_MEMORY_FCTHRASHING</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">kMemorystatusKilledVMCompressorThrashing</span><span class="p">:</span>
				<span class="n">jetsam_reason_code</span> <span class="o">=</span> <span class="n">JETSAM_REASON_MEMORY_VMCOMPRESSOR_THRASHING</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">kMemorystatusKilledVMCompressorSpaceShortage</span><span class="p">:</span>
				<span class="n">jetsam_reason_code</span> <span class="o">=</span> <span class="n">JETSAM_REASON_MEMORY_VMCOMPRESSOR_SPACE_SHORTAGE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">kMemorystatusKilledZoneMapExhaustion</span><span class="p">:</span>
				<span class="n">jetsam_reason_code</span> <span class="o">=</span> <span class="n">JETSAM_REASON_ZONE_MAP_EXHAUSTION</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">kMemorystatusKilledVMPageShortage</span><span class="p">:</span>
				<span class="cm">/* falls through */</span>
			<span class="nl">default:</span>
				<span class="n">jetsam_reason_code</span> <span class="o">=</span> <span class="n">JETSAM_REASON_MEMORY_VMPAGESHORTAGE</span><span class="p">;</span>
				<span class="n">cause</span> <span class="o">=</span> <span class="n">kMemorystatusKilledVMPageShortage</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Highwater */</span>
		<span class="n">boolean_t</span> <span class="n">is_critical</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memorystatus_act_on_hiwat_processes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">errors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hwm_kill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post_snapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">is_critical</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_critical</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*
				 * For now, don't kill any other processes.
				 */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">jetsam_reason</span> <span class="o">=</span> <span class="n">os_reason_create</span><span class="p">(</span><span class="n">OS_REASON_JETSAM</span><span class="p">,</span> <span class="n">jetsam_reason_code</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jetsam_reason</span> <span class="o">==</span> <span class="n">OS_REASON_NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"memorystatus_thread: failed to allocate jetsam reason</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memorystatus_act_aggressive</span><span class="p">(</span><span class="n">cause</span><span class="p">,</span> <span class="n">jetsam_reason</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jld_idle_kills</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">corpse_list_purged</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post_snapshot</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*
		 * memorystatus_kill_top_process() drops a reference,
		 * so take another one so we can continue to use this exit reason
		 * even after it returns
		 */</span>
		<span class="n">os_reason_ref</span><span class="p">(</span><span class="n">jetsam_reason</span><span class="p">);</span>

		<span class="cm">/* LRU */</span>
		<span class="n">killed</span> <span class="o">=</span> <span class="n">memorystatus_kill_top_process</span><span class="p">(</span><span class="n">TRUE</span><span class="p">,</span> <span class="n">sort_flag</span><span class="p">,</span> <span class="n">cause</span><span class="p">,</span> <span class="n">jetsam_reason</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priority</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">errors</span><span class="p">);</span>
		<span class="n">sort_flag</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">killed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memorystatus_post_snapshot</span><span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="n">cause</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>

        			<span class="n">post_snapshot</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Jetsam Loop Detection */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memorystatus_jld_enabled</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">priority</span> <span class="o">==</span> <span class="n">JETSAM_PRIORITY_IDLE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">priority</span> <span class="o">==</span> <span class="n">system_procs_aging_band</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">priority</span> <span class="o">==</span> <span class="n">applications_aging_band</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">jld_idle_kills</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/*
					 * We've reached into bands beyond idle deferred.
					 * We make no attempt to monitor them
					 */</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">priority</span> <span class="o">&gt;=</span> <span class="n">JETSAM_PRIORITY_UI_SUPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">total_corpses_count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">corpse_list_purged</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*
				 * If we have jetsammed a process in or above JETSAM_PRIORITY_UI_SUPPORT
				 * then we attempt to relieve pressure by purging corpse memory.
				 */</span>
				<span class="n">task_purge_all_corpses</span><span class="p">();</span>
				<span class="n">corpse_list_purged</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">memorystatus_avail_pages_below_critical</span><span class="p">())</span> <span class="p">{</span>
			<span class="cm">/*
			 * Still under pressure and unable to kill a process - purge corpse memory
			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">total_corpses_count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">task_purge_all_corpses</span><span class="p">();</span>
				<span class="n">corpse_list_purged</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">memorystatus_avail_pages_below_critical</span><span class="p">())</span> <span class="p">{</span>
				<span class="cm">/*
				 * Still under pressure and unable to kill a process - panic
				 */</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">"memorystatus_jetsam_thread: no victim! available pages:%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">memorystatus_available_pages</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
			
<span class="nl">done:</span>	

<span class="p">}</span>
</code></pre></div></div>

<p>可以看到它开启了一个 循环，memorystatus_action_needed() 来作为循环条件，持续释放内存。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">boolean_t</span>
<span class="nf">memorystatus_action_needed</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if CONFIG_EMBEDDED
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">is_reason_thrashing</span><span class="p">(</span><span class="n">kill_under_pressure_cause</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">is_reason_zone_map_exhaustion</span><span class="p">(</span><span class="n">kill_under_pressure_cause</span><span class="p">)</span> <span class="o">||</span>
	       <span class="n">memorystatus_available_pages</span> <span class="o">&lt;=</span> <span class="n">memorystatus_available_pages_pressure</span><span class="p">);</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_EMBEDDED */</span><span class="cp">
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">is_reason_thrashing</span><span class="p">(</span><span class="n">kill_under_pressure_cause</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">is_reason_zone_map_exhaustion</span><span class="p">(</span><span class="n">kill_under_pressure_cause</span><span class="p">));</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_EMBEDDED */</span><span class="cp">
</span><span class="p">}</span>
</code></pre></div></div>

<p>它通过 vm_pagepout 发送的内存压力来判断当前内存资源是否紧张。几种情况：频繁的页面换出换进 is_reason_thrashing, Mach Zone 耗尽了 is_reason_zone_map_exhaustion、以及可用的页低于了 memory status_available_pages 这个门槛。</p>

<p>继续看 memorystatus_thread，会发现内存紧张时，将先触发 High-water 类型的 OOM，也就是说假如某个进程使用过程中超过了其使用内存的最高限制 hight water mark 时会发生 OOM。在 memorystatus_act_on_hiwat_processes() 中，通过 memorystatus_kill_hiwat_proc()  在优先级数组 memstat_bucket 中查找优先级最低的进程，如果进程的内存小于阈值（footprint_in_bytes  &lt;= memlimit_in_bytes）则继续寻找次优先级较低的进程，直到找到占用内存超过阈值的进程并杀死。</p>

<p>通常来说单个 App 很难触碰到 high water mark，如果不能结束任何进程，最终走到 memorystatus_act_aggressive，也就是大多数 OOM 发生的地方。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">boolean_t</span>
<span class="nf">memorystatus_act_aggressive</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">cause</span><span class="p">,</span> <span class="n">os_reason_t</span> <span class="n">jetsam_reason</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">jld_idle_kills</span><span class="p">,</span> <span class="n">boolean_t</span> <span class="o">*</span><span class="n">corpse_list_purged</span><span class="p">,</span> <span class="n">boolean_t</span> <span class="o">*</span><span class="n">post_snapshot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// ...</span>
  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">jld_bucket_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> 
		     <span class="p">(</span><span class="n">jld_now_msecs</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">jld_timestamp_msecs</span> <span class="o">+</span> <span class="n">memorystatus_jld_eval_period_msecs</span><span class="p">)))</span> <span class="p">{</span>

			<span class="cm">/* 
			 * Refresh evaluation parameters 
			 */</span>
			<span class="n">jld_timestamp_msecs</span>	 <span class="o">=</span> <span class="n">jld_now_msecs</span><span class="p">;</span>
			<span class="n">jld_idle_kill_candidates</span> <span class="o">=</span> <span class="n">jld_bucket_count</span><span class="p">;</span>
			<span class="o">*</span><span class="n">jld_idle_kills</span>		 <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">jld_eval_aggressive_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">jld_priority_band_max</span>	<span class="o">=</span> <span class="n">JETSAM_PRIORITY_UI_SUPPORT</span><span class="p">;</span>
		<span class="p">}</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述代码看到，判断要不要真正执行 kill 是根据一定的时间间判断的，条件是：<code class="highlighter-rouge">jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs</code>。 也就是在 memorystatus_jld_eval_period_msecs 后才发生条件里面的 kill。</p>

<pre><code class="language-C">/* Jetsam Loop Detection */
if (max_mem &lt;= (512 * 1024 * 1024)) {
	/* 512 MB devices */
memorystatus_jld_eval_period_msecs = 8000;	/* 8000 msecs == 8 second window */
} else {
	/* 1GB and larger devices */
memorystatus_jld_eval_period_msecs = 6000;	/* 6000 msecs == 6 second window */
}
</code></pre>

<p>其中 memorystatus_jld_eval_period_msecs 取值最小6秒。所以我们可以在6秒内做些处理。</p>

<h4 id="32-开发者们整理所得">3.2 开发者们整理所得</h4>

<p><a href="https://stackoverflow.com/questions/5887248/ios-app-maximum-memory-budget/15200855#15200855">stackoverflow</a> 上有一份数据，整理了各种设备的 OOM 临界值</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">device</th>
      <th style="text-align: center">crash amount:MB</th>
      <th style="text-align: center">total amount:MB</th>
      <th style="text-align: center">percentage of total</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">iPad1</td>
      <td style="text-align: center">127</td>
      <td style="text-align: center">256</td>
      <td style="text-align: center">49%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad2</td>
      <td style="text-align: center">275</td>
      <td style="text-align: center">512</td>
      <td style="text-align: center">53%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad3</td>
      <td style="text-align: center">645</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">62%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad4(iOS 8.1)</td>
      <td style="text-align: center">585</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">57%</td>
    </tr>
    <tr>
      <td style="text-align: center">Pad Mini 1st Generation</td>
      <td style="text-align: center">297</td>
      <td style="text-align: center">512</td>
      <td style="text-align: center">58%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad Mini retina(iOS 7.1)</td>
      <td style="text-align: center">696</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">68%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad Air</td>
      <td style="text-align: center">697</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">68%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad Air 2(iOS 10.2.1)</td>
      <td style="text-align: center">1383</td>
      <td style="text-align: center">2048</td>
      <td style="text-align: center">68%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad Pro 9.7”(iOS 10.0.2 (14A456))</td>
      <td style="text-align: center">1395</td>
      <td style="text-align: center">1971</td>
      <td style="text-align: center">71%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad Pro 10.5”(iOS 11 beta4)</td>
      <td style="text-align: center">3057</td>
      <td style="text-align: center">4000</td>
      <td style="text-align: center">76%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad Pro 12.9” (2015)(iOS 11.2.1)</td>
      <td style="text-align: center">3058</td>
      <td style="text-align: center">3999</td>
      <td style="text-align: center">76%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPad 10.2(iOS 13.2.3)</td>
      <td style="text-align: center">1844</td>
      <td style="text-align: center">2998</td>
      <td style="text-align: center">62%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPod touch 4th gen(iOS 6.1.1)</td>
      <td style="text-align: center">130</td>
      <td style="text-align: center">256</td>
      <td style="text-align: center">51%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPod touch 5th gen</td>
      <td style="text-align: center">286</td>
      <td style="text-align: center">512</td>
      <td style="text-align: center">56%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone4</td>
      <td style="text-align: center">325</td>
      <td style="text-align: center">512</td>
      <td style="text-align: center">63%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone4s</td>
      <td style="text-align: center">286</td>
      <td style="text-align: center">512</td>
      <td style="text-align: center">56%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone5</td>
      <td style="text-align: center">645</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">62%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone5s</td>
      <td style="text-align: center">646</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">63%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone6(iOS 8.x)</td>
      <td style="text-align: center">645</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">62%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone6 Plus(iOS 8.x)</td>
      <td style="text-align: center">645</td>
      <td style="text-align: center">1024</td>
      <td style="text-align: center">62%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone6s(iOS 9.2)</td>
      <td style="text-align: center">1396</td>
      <td style="text-align: center">2048</td>
      <td style="text-align: center">68%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone6s Plus(iOS 10.2.1)</td>
      <td style="text-align: center">1396</td>
      <td style="text-align: center">2048</td>
      <td style="text-align: center">68%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhoneSE(iOS 9.3)</td>
      <td style="text-align: center">1395</td>
      <td style="text-align: center">2048</td>
      <td style="text-align: center">68%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone7(iOS 10.2)</td>
      <td style="text-align: center">1395</td>
      <td style="text-align: center">2048</td>
      <td style="text-align: center">68%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone7 Plus(iOS 10.2.1)</td>
      <td style="text-align: center">2040</td>
      <td style="text-align: center">3072</td>
      <td style="text-align: center">66%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone8(iOS 12.1)</td>
      <td style="text-align: center">1364</td>
      <td style="text-align: center">1990</td>
      <td style="text-align: center">70%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhoneX(iOS 11.2.1)</td>
      <td style="text-align: center">1392</td>
      <td style="text-align: center">2785</td>
      <td style="text-align: center">50%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhoneXS(iOS 12.1)</td>
      <td style="text-align: center">2040</td>
      <td style="text-align: center">3754</td>
      <td style="text-align: center">54%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhoneXS Max(iOS 12.1)</td>
      <td style="text-align: center">2039</td>
      <td style="text-align: center">3735</td>
      <td style="text-align: center">55%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhoneXR(iOS 12.1)</td>
      <td style="text-align: center">1792</td>
      <td style="text-align: center">2813</td>
      <td style="text-align: center">63%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone11(iOS 13.1.3)</td>
      <td style="text-align: center">2068</td>
      <td style="text-align: center">3844</td>
      <td style="text-align: center">54%</td>
    </tr>
    <tr>
      <td style="text-align: center">iPhone11 Pro Max(iOS 13.2.3)</td>
      <td style="text-align: center">2067</td>
      <td style="text-align: center">3740</td>
      <td style="text-align: center">55%</td>
    </tr>
  </tbody>
</table>

<h4 id="33-触发当前-app-的-high-water-mark">3.3 触发当前 App 的 high water mark</h4>

<p>我们可以写定时器，不断的申请内存，之后再通过 <code class="highlighter-rouge">phys_footprint</code> 打印当前占用内存，按道理来说不断申请内存即可触发 Jetsam 机制，强杀 App，那么<strong>最后一次打印的内存占用也就是当前设备的内存上限值</strong>。</p>

<pre><code class="language-objectivec">timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(allocateMemory) userInfo:nil repeats:YES];

- (void)allocateMemory {
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
    UIImage *image = [UIImage imageNamed:@"AppIcon"];
    imageView.image = image;
    [array addObject:imageView];
    
    memoryLimitSizeMB = [self usedSizeOfMemory];
    if (memoryWarningSizeMB &amp;&amp; memoryLimitSizeMB) {
        NSLog(@"----- memory warnning:%dMB, memory limit:%dMB", memoryWarningSizeMB, memoryLimitSizeMB);
    }
}

- (int)usedSizeOfMemory {
    task_vm_info_data_t taskInfo;
    mach_msg_type_number_t infoCount = TASK_VM_INFO_COUNT;
    kern_return_t kernReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);

    if (kernReturn != KERN_SUCCESS) {
        return 0;
    }
    return (int)(taskInfo.phys_footprint/1024.0/1024.0);
}
</code></pre>

<h4 id="34-适用于-ios13-系统的获取方式">3.4 适用于 iOS13 系统的获取方式</h4>

<p>iOS13 开始 &lt;os/proc.h&gt; 中 <code class="highlighter-rouge">size_t os_proc_available_memory(void); </code> 可以查看当前可用内存。</p>

<blockquote>
  <p>Return Value</p>

  <p>The number of bytes that the app may allocate before it hits its memory limit. If the calling process isn’t an app, or if the process has already exceeded its memory limit, this function returns <code class="highlighter-rouge">0</code>.</p>

  <p>Discussion</p>

  <p>Call this function to determine the amount of memory available to your app. The returned value corresponds to the current memory limit minus the memory footprint of your app at the time of the function call. Your app’s memory footprint consists of the data that you allocated in RAM, and that must stay in RAM (or the equivalent) at all times. Memory limits can change during the app life cycle and don’t necessarily correspond to the amount of physical memory available on the device.</p>

  <p>Use the returned value as advisory information only and don’t cache it. The precise value changes when your app does any work that affects memory, which can happen frequently.</p>

  <p>Although this function lets you determine the amount of memory your app may safely consume, don’t use it to maximize your app’s memory usage. Significant memory use, even when under the current memory limit, affects system performance. For example, when your app consumes all of its available memory, the system may need to terminate other apps and system processes to accommodate your app’s requests. Instead, always consume the smallest amount of memory you need to be responsive to the user’s needs.</p>

  <p>If you need more detailed information about the available memory resources, you can call <a href="apple-reference-documentation://hcPGvbcfam"><code class="highlighter-rouge">task_info</code></a>. However, be aware that <code class="highlighter-rouge">task_info</code> is an expensive call, whereas this function is much more efficient.</p>
</blockquote>

<pre><code class="language-objectivec">if (@available(iOS 13.0, *)) {
	return os_proc_available_memory() / 1024.0 / 1024.0;
}
</code></pre>

<p>App 内存信息的 API 可以在 Mach 层找到，<code class="highlighter-rouge">mach_task_basic_info</code> 结构体存储了 Mach task 的内存使用信息，其中 phys_footprint 就是应用使用的物理内存大小，virtual_size 是虚拟内存大小。</p>

<pre><code class="language-objectivec">#define MACH_TASK_BASIC_INFO     20         /* always 64-bit basic info */
struct mach_task_basic_info {
    mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */
    mach_vm_size_t  resident_size;      /* resident memory size (bytes) */
    mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */
    time_value_t    user_time;          /* total user run time for
                                            terminated threads */
    time_value_t    system_time;        /* total system run time for
                                            terminated threads */
    policy_t        policy;             /* default policy for new threads */
    integer_t       suspend_count;      /* suspend count for task */
};
</code></pre>

<p><strong>所以获取代码为：</strong></p>

<pre><code class="language-objectivec">task_vm_info_data_t vmInfo;
mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
kern_return_t kr = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;vmInfo, &amp;count);

if (kr != KERN_SUCCESS) {
    return ;
}
CGFloat memoryUsed = (CGFloat)(vmInfo.phys_footprint/1024.0/1024.0);
</code></pre>

<p>可能有人好奇不应该是 <code class="highlighter-rouge">resident_size</code> 这个字段获取内存的使用情况吗？一开始测试后发现 resident_size 和 Xcode 测量结果差距较大。而使用 phys_footprint 则接近于 Xcode 给出的结果。且可以从 <a href="https://github.com/WebKit/webkit/blob/52bc6f0a96a062cb0eb76e9a81497183dc87c268/Source/WTF/wtf/cocoa/MemoryFootprintCocoa.cpp">WebKit 源码</a>中得到印证。</p>

<p>所以在 iOS13 上，我们可以通过 <code class="highlighter-rouge">os_proc_available_memory</code> 获取到当前可以用内存，通过 <code class="highlighter-rouge">phys_footprint</code> 获取到当前 App 占用内存，2者的和也就是当前设备的内存上限，超过即触发 Jetsam 机制。</p>

<pre><code class="language-objectivec">- (CGFloat)limitSizeOfMemory {
    if (@available(iOS 13.0, *)) {
        task_vm_info_data_t taskInfo;
        mach_msg_type_number_t infoCount = TASK_VM_INFO_COUNT;
        kern_return_t kernReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);

        if (kernReturn != KERN_SUCCESS) {
            return 0;
        }
        return (CGFloat)((taskInfo.phys_footprint + os_proc_available_memory()) / (1024.0 * 1024.0);
    }
    return 0;
}
</code></pre>

<p>当前可以使用内存：1435.936752MB；当前 App 已占用内存：14.5MB，临界值：1435.936752MB + 14.5MB= 1450.436MB， 和 3.1 方法中获取到的内存临界值一样「iPhone 6s plus/13.3.1 手机 OOM 临界值为：(16384*92806)/(1024*1024)=1450.09375M」。</p>

<h4 id="35-通过-xnu-获取内存限制值">3.5 通过 XNU 获取内存限制值</h4>

<p>在 XNU 中，有专门用于获取内存上限值的函数和宏，可以通过 <code class="highlighter-rouge">memorystatus_priority_entry</code> 这个结构体得到所有进程的优先级和内存限制值。</p>

<pre><code class="language-objectivec">typedef struct memorystatus_priority_entry {
  pid_t pid;
  int32_t priority;
  uint64_t user_data;
  int32_t limit;
  uint32_t state;
} memorystatus_priority_entry_t;
</code></pre>

<p>其中，priority 代表进程优先级，limit 代表进程的内存限制值。但是这种方式需要 root 权限，由于没有越狱设备，我没有尝试过。</p>

<p>相关代码可查阅 <code class="highlighter-rouge">kern_memorystatus.h</code> 文件。需要用到函数 <code class="highlighter-rouge">int memorystatus_control(uint32_t command, int32_t pid, uint32_t flags, void *buffer, size_t buffersize);</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Commands */</span>
<span class="cp">#define MEMORYSTATUS_CMD_GET_PRIORITY_LIST            1
#define MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES      2
#define MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT          3
#define MEMORYSTATUS_CMD_GET_PRESSURE_STATUS          4
#define MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK   5    </span><span class="cm">/* Set active memory limit = inactive memory limit, both non-fatal	*/</span><span class="cp">
#define MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT	      6    </span><span class="cm">/* Set active memory limit = inactive memory limit, both fatal	*/</span><span class="cp">
#define MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES      7    </span><span class="cm">/* Set memory limits plus attributes independently			*/</span><span class="cp">
#define MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES      8    </span><span class="cm">/* Get memory limits plus attributes					*/</span><span class="cp">
#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE   9    </span><span class="cm">/* Set the task's status as a privileged listener w.r.t memory notifications  */</span><span class="cp">
#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE  10   </span><span class="cm">/* Reset the task's status as a privileged listener w.r.t memory notifications  */</span><span class="cp">
#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_ENABLE  11   </span><span class="cm">/* Enable the 'lenient' mode for aggressive jetsam. See comments in kern_memorystatus.c near the top. */</span><span class="cp">
#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_DISABLE 12   </span><span class="cm">/* Disable the 'lenient' mode for aggressive jetsam. */</span><span class="cp">
#define MEMORYSTATUS_CMD_GET_MEMLIMIT_EXCESS          13   </span><span class="cm">/* Compute how much a process's phys_footprint exceeds inactive memory limit */</span><span class="cp">
#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_ENABLE 	14 </span><span class="cm">/* Set the inactive jetsam band for a process to JETSAM_PRIORITY_ELEVATED_INACTIVE */</span><span class="cp">
#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_DISABLE 	15 </span><span class="cm">/* Reset the inactive jetsam band for a process to the default band (0)*/</span><span class="cp">
#define MEMORYSTATUS_CMD_SET_PROCESS_IS_MANAGED       16   </span><span class="cm">/* (Re-)Set state on a process that marks it as (un-)managed by a system entity e.g. assertiond */</span><span class="cp">
#define MEMORYSTATUS_CMD_GET_PROCESS_IS_MANAGED       17   </span><span class="cm">/* Return the 'managed' status of a process */</span><span class="cp">
#define MEMORYSTATUS_CMD_SET_PROCESS_IS_FREEZABLE     18   /* Is the process eligible for freezing? Apps and extensions can pass in FALSE to opt out of freezing, i.e.,
</span></code></pre></div></div>

<p><strong>伪代码</strong></p>

<pre><code class="language-objectivec">struct memorystatus_priority_entry memStatus[NUM_ENTRIES];
size_t count = sizeof(struct memorystatus_priority_entry) * NUM_ENTRIES;
int kernResult = memorystatus_control(MEMORYSTATUS_CMD_GET_PRIORITY_LIST, 0, 0, memStatus, count);
if (rc &lt; 0) {
  NSLog(@"memorystatus_control"); 
	return ;
}

int entry = 0;
for (; rc &gt; 0; rc -= sizeof(struct memorystatus_priority_entry)){
  printf ("PID: %5d\tPriority:%2d\tUser Data: %llx\tLimit:%2d\tState:%s\n",
          memstatus[entry].pid,
          memstatus[entry].priority,
          memstatus[entry].user_data,
          memstatus[entry].limit,
          state_to_text(memstatus[entry].state));
  entry++;
}
</code></pre>

<p>for 循环打印出每个进程（也就是 App）的 pid、Priority、User Data、Limit、State 信息。从 log 中找出优先级为10的进程，即我们前台运行的 App。为什么是10？ 因为 <code class="highlighter-rouge">#define JETSAM_PRIORITY_FOREGROUND               10</code> 我们的目的就是获取前台 App 的内存上限值。</p>

<h3 id="4-如何判定发生了-oom">4. 如何判定发生了 OOM</h3>

<p>OOM 导致 crash 前，app 一定会收到低内存警告吗？</p>

<p>做 2 组对比实验：</p>

<pre><code class="language-objectivec">// 实验1
NSMutableArray *array = [NSMutableArray array];
for (NSInteger index = 0; index &lt; 10000000; index++) {
  NSString *filePath = [[NSBundle mainBundle] pathForResource:@"Info" ofType:@"plist"];
  NSData *data = [NSData dataWithContentsOfFile:filePath];
  [array addObject:data];
}
</code></pre>

<pre><code class="language-objectivec">// 实验2
// ViewController.m
- (void)viewDidLoad {
    [super viewDidLoad];
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSMutableArray *array = [NSMutableArray array];
        for (NSInteger index = 0; index &lt; 10000000; index++) {
            NSString *filePath = [[NSBundle mainBundle] pathForResource:@"Info" ofType:@"plist"];
            NSData *data = [NSData dataWithContentsOfFile:filePath];
            [array addObject:data];
        }
    });
}
- (void)didReceiveMemoryWarning
{
    NSLog(@"2");
}

// AppDelegate.m
- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application
{
    NSLog(@"1");
}
</code></pre>

<p><strong>现象：</strong></p>

<ol>
  <li>在 viewDidLoad 也就是主线程中内存消耗过大，系统并不会发出低内存警告，直接 Crash。因为内存增长过快，主线程很忙。</li>
  <li>多线程的情况下，App 因内存增长过快，会收到低内存警告，AppDelegate 中的<code class="highlighter-rouge">applicationDidReceiveMemoryWarning</code>  先执行，随后是当前 VC 的 <code class="highlighter-rouge">didReceiveMemoryWarning</code>。</li>
</ol>

<p><strong>结论：</strong></p>

<p><strong>收到低内存警告不一定会 Crash，因为有6秒钟的系统判断时间，6秒内内存下降了则不会 crash。发生 OOM 也不一定会收到低内存警告。</strong></p>

<h3 id="5--内存信息收集">5.  内存信息收集</h3>

<p>要想精确的定位问题，就需要 dump 所有对象及其内存信息。当内存接近系统内存上限的时候，收集并记录所需信息，结合一定的数据上报机制，上传到服务器，分析并修复。</p>

<p>还需要知道每个对象具体是在哪个函数里创建出来的，以便还原“案发现场”。</p>

<p>源代码（libmalloc/malloc），内存分配函数 malloc 和  calloc 等默认使用 nano_zone，nano_zone 是小于 256B 以下的内存分配，大于 256B 则使用 scalable_zone 来分配。</p>

<p>主要针对大内存的分配监控。malloc 函数用的是 malloc_zone_malloc, calloc 用的是 malloc_zone_calloc。</p>

<p>使用 scalable_zone 分配内存的函数都会调用 malloc_logger 函数，因为系统为了有个地方专门统计并管理内存分配情况。这样的设计也满足「收口原则」。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span>
<span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">malloc_zone_malloc</span><span class="p">(</span><span class="n">default_zone</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">errno</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_items</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">malloc_zone_calloc</span><span class="p">(</span><span class="n">default_zone</span><span class="p">,</span> <span class="n">num_items</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">errno</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先来看看这个 <code class="highlighter-rouge">default_zone</code> 是什么东西, 代码如下</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">malloc_zone_t</span> <span class="n">malloc_zone</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">pad</span><span class="p">[</span><span class="n">PAGE_MAX_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">malloc_zone_t</span><span class="p">)];</span>
<span class="p">}</span> <span class="n">virtual_default_zone_t</span><span class="p">;</span>

<span class="k">static</span> <span class="n">virtual_default_zone_t</span> <span class="n">virtual_default_zone</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">"__DATA,__v_zone"</span><span class="p">)))</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="n">PAGE_MAX_SIZE</span><span class="p">)))</span> <span class="o">=</span> <span class="p">{</span>
	<span class="nb">NULL</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
	<span class="n">default_zone_size</span><span class="p">,</span>
	<span class="n">default_zone_malloc</span><span class="p">,</span>
	<span class="n">default_zone_calloc</span><span class="p">,</span>
	<span class="n">default_zone_valloc</span><span class="p">,</span>
	<span class="n">default_zone_free</span><span class="p">,</span>
	<span class="n">default_zone_realloc</span><span class="p">,</span>
	<span class="n">default_zone_destroy</span><span class="p">,</span>
	<span class="n">DEFAULT_MALLOC_ZONE_STRING</span><span class="p">,</span>
	<span class="n">default_zone_batch_malloc</span><span class="p">,</span>
	<span class="n">default_zone_batch_free</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">default_zone_introspect</span><span class="p">,</span>
	<span class="mi">10</span><span class="p">,</span>
	<span class="n">default_zone_memalign</span><span class="p">,</span>
	<span class="n">default_zone_free_definite_size</span><span class="p">,</span>
	<span class="n">default_zone_pressure_relief</span><span class="p">,</span>
	<span class="n">default_zone_malloc_claimed_address</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">malloc_zone_t</span> <span class="o">*</span><span class="n">default_zone</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">virtual_default_zone</span><span class="p">.</span><span class="n">malloc_zone</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">default_zone_malloc</span><span class="p">(</span><span class="n">malloc_zone_t</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">zone</span> <span class="o">=</span> <span class="n">runtime_default_zone</span><span class="p">();</span>
	
	<span class="k">return</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">malloc</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">MALLOC_ALWAYS_INLINE</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">malloc_zone_t</span> <span class="o">*</span>
<span class="nf">runtime_default_zone</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">lite_zone</span><span class="p">)</span> <span class="o">?</span> <span class="n">lite_zone</span> <span class="o">:</span> <span class="n">inline_malloc_default_zone</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到 <code class="highlighter-rouge">default_zone</code> 通过这种方式来初始化</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="n">malloc_zone_t</span> <span class="o">*</span>
<span class="nf">inline_malloc_default_zone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_malloc_initialize_once</span><span class="p">();</span>
	<span class="c1">// malloc_report(ASL_LEVEL_INFO, "In inline_malloc_default_zone with %d %d\n", malloc_num_zones, malloc_has_debug_zone);</span>
	<span class="k">return</span> <span class="n">malloc_zones</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>随后的调用如下</strong></p>

<p><code class="highlighter-rouge">_malloc_initialize</code> -&gt; <code class="highlighter-rouge">create_scalable_zone</code> -&gt; <code class="highlighter-rouge">create_scalable_szone</code> 最终我们创建了 szone_t 类型的对象，通过类型转换，得到了我们的 default_zone。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">malloc_zone_t</span> <span class="o">*</span>
<span class="nf">create_scalable_zone</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">initial_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">debug_flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">malloc_zone_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">create_scalable_szone</span><span class="p">(</span><span class="n">initial_size</span><span class="p">,</span> <span class="n">debug_flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc_zone_malloc</span><span class="p">(</span><span class="n">malloc_zone_t</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">MALLOC_TRACE</span><span class="p">(</span><span class="n">TRACE_malloc</span> <span class="o">|</span> <span class="n">DBG_FUNC_START</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">zone</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">malloc_check_start</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">malloc_check_counter</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">malloc_check_start</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">internal_check</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">MALLOC_ABSOLUTE_MAX_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">malloc</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="c1">// 在 zone 分配完内存后就开始使用 malloc_logger 进行进行记录</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">malloc_logger</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">malloc_logger</span><span class="p">(</span><span class="n">MALLOC_LOG_TYPE_ALLOCATE</span> <span class="o">|</span> <span class="n">MALLOC_LOG_TYPE_HAS_ZONE</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">zone</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">MALLOC_TRACE</span><span class="p">(</span><span class="n">TRACE_malloc</span> <span class="o">|</span> <span class="n">DBG_FUNC_END</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">zone</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其分配实现是 <code class="highlighter-rouge">zone-&gt;malloc</code> 根据之前的分析，就是szone_t结构体对象中对应的malloc实现。</p>

<p>在创建szone之后，做了一系列如下的初始化操作。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Initialize the security token.</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">malloc_entropy</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_size</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">malloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_malloc</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">calloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_calloc</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">valloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_valloc</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_free</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">realloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_realloc</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_destroy</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">batch_malloc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_batch_malloc</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">batch_free</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_batch_free</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">introspect</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">malloc_introspection_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">szone_introspect</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">memalign</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_memalign</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">free_definite_size</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_free_definite_size</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">pressure_relief</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_pressure_relief</span><span class="p">;</span>
<span class="n">szone</span><span class="o">-&gt;</span><span class="n">basic_zone</span><span class="p">.</span><span class="n">claimed_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">szone_claimed_address</span><span class="p">;</span>
</code></pre></div></div>

<p>其他使用 scalable_zone 分配内存的函数的方法也类似，所以大内存的分配，不管外部函数如何封装，最终都会调用到 malloc_logger 函数。所以我们可以用 fishhook 去 hook 这个函数，然后记录内存分配情况，结合一定的数据上报机制，上传到服务器，分析并修复。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// For logging VM allocation and deallocation, arg1 here
// is the mach_port_name_t of the target task in which the
// alloc or dealloc is occurring. For example, for mmap()
// that would be mach_task_self(), but for a cross-task-capable
// call such as mach_vm_map(), it is the target task.

typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);

extern malloc_logger_t *__syscall_logger;
</code></pre></div></div>

<p>当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 dsym 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样 <strong>符号表地址 = 堆栈地址 - slide。</strong></p>

<p><strong>小 tips：</strong></p>

<p>ASLR（Address space layout randomization）：常见称呼为位址空间随机载入、位址空间配置随机化、位址空间布局随机化，是一种防止内存损坏漏洞被利用的计算机安全技术，通过随机放置进程关键数据区域的定址空间来放置攻击者能可靠地跳转到内存的特定位置来操作函数。现代作业系统一般都具备该机制。</p>

<p>函数地址 add:  函数真实的实现地址;</p>

<p>函数虚拟地址：<code class="highlighter-rouge">vm_add</code>;</p>

<p>ASLR:  <code class="highlighter-rouge">slide</code> 函数虚拟地址加载到进程内存的随机偏移量，每个 mach-o 的 slide 各不相同。<code class="highlighter-rouge">vm_add + slide = add</code>。也就是：<code class="highlighter-rouge">*(base +offset)= imp</code>。</p>

<p>由于腾讯也开源了自己的 OOM 定位方案- <a href="https://github.com/Tencent/OOMDetector">OOMDetector</a> ，有了现成的轮子，那么用好就可以了，所以对于内存的监控思路就是找到系统给 App 的内存上限，然后当接近内存上限值的时候，dump 内存情况，组装基础数据信息成一个合格的上报数据，经过一定的数据上报策略到服务端，服务端消费数据，分析产生报表，客户端工程师根据报表分析问题。不同工程的数据以邮件、短信、企业微信等形式通知到该项目的 owner、开发者。（情况严重的会直接电话给开发者，并给主管跟进每一步的处理结果）。
问题分析处理后要么发布新版本，要么 hot fix。</p>

<h3 id="6-开发阶段针对内存我们能做些什么">6. 开发阶段针对内存我们能做些什么</h3>

<ol>
  <li>
    <p>图片缩放</p>

    <p>WWDC 2018 Session 416 - iOS Memory Deep Dive，处理图片缩放的时候直接使用 UIImage 会在解码时读取文件而占用一部分内存，还会生成中间位图 bitmap 消耗大量内存。而 <strong>ImageIO</strong> 不存在上述2种弊端，只会占用最终图片大小的内存</p>

    <p>做了2组对比实验：给 App 显示一张图片</p>

    <pre><code class="language-objectivec">// 方法1: 19.6M
UIImage *imageResult = [self scaleImage:[UIImage imageNamed:@"test"]                                                  newSize:CGSizeMake(self.view.frame.size.width, self.view.frame.size.height)];
self.imageView.image = imageResult;
   
// 方法2: 14M
NSData *data = UIImagePNGRepresentation([UIImage imageNamed:@"test"]);
UIImage *imageResult = [self scaledImageWithData:data 				    withSize:CGSizeMake(self.view.frame.size.width, self.view.frame.size.height) scale:3 orientation:UIImageOrientationUp];
self.imageView.image = imageResult;
   
- (UIImage *)scaleImage:(UIImage *)image newSize:(CGSize)newSize
{
    UIGraphicsBeginImageContextWithOptions(newSize, NO, 0);
    [image drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)];
    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
   
- (UIImage *)scaledImageWithData:(NSData *)data withSize:(CGSize)size scale:(CGFloat)scale orientation:(UIImageOrientation)orientation
{
    CGFloat maxPixelSize = MAX(size.width, size.height);
    CGImageSourceRef sourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, nil);
    NSDictionary *options = @{(__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue,
                              (__bridge id)kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize]};
    CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(sourceRef, 0, (__bridge CFDictionaryRef)options);
    UIImage *resultImage = [UIImage imageWithCGImage:imageRef scale:scale orientation:orientation];
    CGImageRelease(imageRef);
    CFRelease(sourceRef);
    return resultImage;
}
</code></pre>

    <p>可以看出使用 ImageIO 比使用 UIImage 直接缩放占用内存更低。</p>
  </li>
  <li>
    <p>合理使用 autoreleasepool</p>

    <p>我们知道 autoreleasepool 对象是在 RunLoop 结束时才释放。在 ARC 下，我们如果在不断申请内存，比如各种循环，那么我们就需要手动添加 autoreleasepool，避免短时间内内存猛涨发生 OOM。</p>
  </li>
</ol>

<p><strong>对比实验</strong></p>

<pre><code class="language-objectivec">  // 实验1
  NSMutableArray *array = [NSMutableArray array];
  for (NSInteger index = 0; index &lt; 10000000; index++) {
    NSString *indexStrng = [NSString stringWithFormat:@"%zd", index];
    NSString *resultString = [NSString stringWithFormat:@"%zd-%@", index, indexStrng];
    [array addObject:resultString];
  }
  
  // 实验2
  NSMutableArray *array = [NSMutableArray array];
  for (NSInteger index = 0; index &lt; 10000000; index++) {
    @autoreleasepool {
      NSString *indexStrng = [NSString stringWithFormat:@"%zd", index];
      NSString *resultString = [NSString stringWithFormat:@"%zd-%@", index, indexStrng];
      [array addObject:resultString];
    }
  }
</code></pre>

<p>实验1消耗内存 739.6M，实验2消耗内存 587M。</p>

<ol>
  <li>
    <p>UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode 的 Analyze 也能扫出这类问题。</p>
  </li>
  <li>
    <p>不管是打开网页，还是执行 js，都应该使用 WKWebView。UIWebView 会占用大量内存，从而导致 App 发生 OOM 的几率增加，而 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行，比 UIWebView 占用更低的内存开销。</p>
  </li>
  <li>
    <p>在做 SDK 或者 App，如果场景是缓存相关，尽量使用 NSCache 而不是 NSMutableDictionary。它是系统提供的专门处理缓存的类，NSCache 分配的内存是 <code class="highlighter-rouge">Purgeable Memory</code>，可以由系统自动释放。NSCache 与 NSPureableData 的结合使用可以让系统根据情况回收内存，也可以在内存清理时移除对象。</p>

    <p>其他的开发习惯就不一一描述了，良好的开发习惯和代码意识是需要平时注意修炼的。</p>
  </li>
</ol>

  </section>
</article>
<span id="busuanzi_container_page_pv"> | 访问量：<span id="busuanzi_value_page_pv"></span> 次</span>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2020/07/%E5%B8%A6%E4%BD%A0%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97-APM-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E4%B8%89/" title="link to 带你打造一套 APM 监控系统（三）">带你打造一套 APM 监控系统（三）</a></h2>
       <p class="excerpt">五、 App 网络监控移动网络环境一直很复杂，WIFI、2G、3G、4G、5G 等，用户使用 App 的过程中可能在这几种类型之间切换，这也是移动网络和传统网络间的一个区别，被称为「Connection Migration」。此外还存在 DNS 解析缓慢、失败率高、运营商劫持等问题。用户在使用 App 时因为某些原因导致体验很差，要想针对网络情况进行改善，必须有清晰的监控手段。1. App 网络请求过程App 发送一次网络请求一般会经历下面几个关键步骤：      DNS 解析    Do...&hellip;</p>
       <div class="post-list__meta"><time datetime="2020-07-14 13:00:37 +0800" class="post-list__meta--date date">2020-07-14</time> &#8226; <span class="post-list__meta--tags tags">iOS</span><a class="btn-border-small" href=/2020/07/%E5%B8%A6%E4%BD%A0%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97-APM-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E4%B8%89/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2020/07/%E5%B8%A6%E4%BD%A0%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97-APM-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E4%B8%80/" title="link to 带你打造一套 APM 监控系统（一）">带你打造一套 APM 监控系统（一）</a></h2>
       <p class="excerpt">  APM 是 Application Performance Monitoring 的缩写，监视和管理软件应用程序的性能和可用性。应用性能管理对一个应用的持续稳定运行至关重要。所以这篇文章就从一个 iOS App 的性能管理的纬度谈谈如何精确监控以及数据如何上报等技术点App 的性能问题是影响用户体验的重要因素之一。性能问题主要包含：Crash、网络请求错误或者超时、UI 响应速度慢、主线程卡顿、CPU 和内存使用率高、耗电量大等等。大多数的问题原因在于开发者错误地使用了线程锁、系统函数...&hellip;</p>
       <div class="post-list__meta"><time datetime="2020-07-14 12:56:30 +0800" class="post-list__meta--date date">2020-07-14</time> &#8226; <span class="post-list__meta--tags tags">iOS</span><a class="btn-border-small" href=/2020/07/%E5%B8%A6%E4%BD%A0%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97-APM-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E4%B8%80/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2020-12-09 生成</span>
        <span class="footer__copyright">本站由 <a href="http://gsnice.com">@GSNICE</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2020</span>
    </footer>
</section>
<span id="busuanzi_container_site_pv">本站总访问量：<span id="busuanzi_value_site_pv"></span>次</span>


        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>



<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
